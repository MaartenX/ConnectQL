/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
-->begin

using System;
using System.CodeDom.Compiler;
using System.IO;
using System.Collections.Generic;

-->namespace


	/// <summary>
	/// The token.
	/// </summary>
	[GeneratedCode("CoCo/R", "0.1")]
	internal class Token
	{
		/// <summary>
		/// Gets or sets a value indicating whether the token is comment.
		/// </summary>
		public bool IsComment { get; set; }

		/// <summary>
		/// Gets or sets the tokens index.
		/// </summary>
		public int Index { get; set; }

		/// <summary>
		/// Gets or sets the token kind.
		/// </summary>
		public int Kind { get; set; }

		/// <summary>
		/// Gets or sets the token position in bytes in the source text (starting at 0).
		/// </summary>
		public int Pos { get; set; }

		/// <summary>
		/// Gets or sets the token position in characters in the source text (starting at 0).
		/// </summary>
		public int CharPos { get; set; }

		/// <summary>
		/// Gets or sets the token column (starting at 1).
		/// </summary>
		public int Col { get; set; }

		/// <summary>
		/// Gets or sets the token line (starting at 1).
		/// </summary>
		public int Line { get; set; }

		/// <summary>
		/// Gets or sets the token value.
		/// </summary>
		public string Val { get; set; }

		/// <summary>
		/// Gets or sets the ML 2005-03-11 Tokens are kept in linked list.
		/// </summary>
		public Token Next { get; set; }
	}
	
	/// <summary>
	/// The Buffer.
	/// This Buffer supports the following cases:
    /// 1) seekable stream (file)
    ///    a) whole stream in Buffer
    ///    b) part of stream in Buffer
    /// 2) non seekable stream (network, console)
	/// </summary>
	[GeneratedCode("CoCo/R", "0.1")]
	internal class Buffer
	{
		/// <summary>
		/// The end of file token.
		/// </summary>
		public const int Eof = char.MaxValue + 1;

		/// <summary>
		/// The minimum buffer length.
		/// </summary>
		private const int MinBufferLength = 1024; // 1KB
		
		/// <summary>
		/// The maximum buffer length.
		/// </summary>
		private const int MaxBufferLength = MinBufferLength * 64; // 64KB

		/// <summary>
		/// The input buffer.
		/// </summary>
		private byte[] byteBuffer;         

		/// <summary>
		/// The position of first byte in the buffer relative to input stream.
		/// </summary>
		private int firstByte;       
		
		/// <summary>
		/// The length of the buffer.
		/// </summary>
		private int bufferLength;         

		/// <summary>
		/// The length of input stream (may change if the stream is no file).
		/// </summary>
		private int inputStreamLength;        
		
		/// <summary>
		/// The current position in the buffer.
		/// </summary>
		private int currentPosition;   
		
		/// <summary>
		/// The input stream (seekable).
		/// </summary>
		private Stream stream; 
		
		/// <summary>
		/// <c>true</c> if the stream was opened by the user.
		/// </summary>
		private bool isUserStream;

		/// <summary>
		/// Initializes a new instance of the <see cref="Buffer" /> class.
		/// </summary>
		/// <param name="stream">
		/// The stream.
		/// </param>
		/// <param name="isUserStream">
		/// <c>true</c> if the stream was opened by the user.
		/// </param>
		public Buffer(Stream stream, bool isUserStream)
		{
				this.stream = stream;
				this.isUserStream = isUserStream;

			if (this.stream.CanSeek)
			{
					this.inputStreamLength = (int)this.stream.Length;
					this.bufferLength = Math.Min(this.inputStreamLength, MaxBufferLength);
					this.firstByte = int.MaxValue; // nothing in the Buffer so far
			}
			else
			{
					this.inputStreamLength = this.bufferLength = this.firstByte = 0;
			}

				this.byteBuffer = new byte[(this.bufferLength > 0) ? this.bufferLength : MinBufferLength];
			if (this.inputStreamLength > 0)
				{
					this.Pos = 0; // setup Buffer to position 0 (start)
				}
				else
				{
					this.currentPosition = 0; // index 0 is already after the file, thus Pos = 0 is invalid
				}

				if (this.bufferLength == this.inputStreamLength && this.stream.CanSeek)
				{
					this.Close();
				}
			}
			
		/// <summary>
		/// Initializes a new instance of the <see cref="Buffer" /> class.
		/// Called in UTF8Buffer constructor.
		/// </summary>
		/// <param name="b">
		/// The buffer to base this buffer on.
		/// </param>
		protected Buffer(Buffer b)
		{ 
			this.byteBuffer = b.byteBuffer;
			this.firstByte = b.firstByte;
			this.bufferLength = b.bufferLength;
			this.inputStreamLength = b.inputStreamLength;
			this.currentPosition = b.currentPosition;
			this.stream = b.stream;
			
			b.stream = null;
			this.isUserStream = b.isUserStream;
		}

		~Buffer()
		{
			this.Close();
		}

		/// <summary>
		/// Closes the buffer.
		/// </summary>
		protected void Close()
		{
			if (!this.isUserStream && this.stream != null)
			{
					this.stream.Dispose();
					this.stream = null;
			}
		}
		
		/// <summary>
		/// Reads a character from the buffer and moves the buffer pointer.
		/// </summary>
		/// <returns>
		///	The character.
		/// </returns>
		public virtual int Read()
		{
			if (this.currentPosition < this.bufferLength)
			{
				return this.byteBuffer[this.currentPosition++];
			}
			else if (this.Pos < this.inputStreamLength)
			{
					this.Pos = this.Pos; // shift Buffer start to Pos
				return this.byteBuffer[this.currentPosition++];
			}
			else if (this.stream != null && !this.stream.CanSeek && this.ReadNextStreamChunk() > 0)
			{
				return this.byteBuffer[this.currentPosition++];
			}
	else
			{
				return Eof;
			}
		}
		
		/// <summary>
		/// Reads a character from the buffer without moving the buffer pointer.
		/// </summary>
		/// <returns>
		///	The character.
		/// </returns>
		public int Peek()
		{
			var curPos = this.Pos;
			var ch = this.Read();
				this.Pos = curPos;
			return ch;
		}

		
		/// <summary>
		/// Gets a string starting at the beg position until the end position.
		/// </summary>
		/// <param name="beg">
		/// The position of the beginning of the string, zero-based inclusive in bytes.
		/// </param>
		/// <param name="end">
		/// The position of the end of the string, zero-based inclusive in bytes.
		/// </param>
		/// <returns>
		///	The string.
		/// </returns>
		public string GetString(int beg, int end)
		{
			var len = 0;
			var byteBuffer = new char[end - beg];
			var oldPos = this.Pos;
				this.Pos = beg;
			while (this.Pos < end)
				{
					byteBuffer[len++] = (char)this.Read();
				}

				this.Pos = oldPos;
			return new string(byteBuffer, 0, len);
		}

		/// <summary>
		/// Gets or sets the position in the buffer.
		/// </summary>
		public int Pos
		{
			get
			{
				return this.currentPosition + this.firstByte;
			}

			set
			{
				if (value >= this.inputStreamLength && this.stream != null && !this.stream.CanSeek)
				{
					// Wanted position is after Buffer and the stream
					// is not seek-able e.g. network or console,
					// thus we have to read the stream manually till
					// the wanted position is in sight.
					while (value >= this.inputStreamLength && this.ReadNextStreamChunk() > 0)
						{
						}
					}

				if (value < 0 || value > this.inputStreamLength)
				{
					throw new FatalError("Buffer out of bounds access, position: " + value);
				}

				if (value >= this.firstByte && value < this.firstByte + this.bufferLength)
				{ // already in Buffer
						this.currentPosition = value - this.firstByte;
				}
				else if (this.stream != null)
				{ // must be swapped in
						this.stream.Seek(value, SeekOrigin.Begin);
						this.bufferLength = this.stream.Read(this.byteBuffer, 0, this.byteBuffer.Length);
						this.firstByte = value;
						this.currentPosition = 0;
				}
	else
				{
						// set the position to the end of the file, Pos will return inputStreamLength.
						this.currentPosition = this.inputStreamLength - this.firstByte;
				}
			}
		}

		/// <summary>
		/// Read the next chunk of bytes from the stream, increases the Buffer
		/// if needed and updates the fields inputStreamLength and bufferLength.
		/// </summary>
		/// <returns>
		/// The number of bytes read.
		/// </returns>
		private int ReadNextStreamChunk()
		{
			var free = this.byteBuffer.Length - this.bufferLength;
			if (free == 0)
			{
				// in the case of a growing input stream
				// we can neither seek in the stream, nor can we
				// foresee the maximum length, thus we must adapt
				// the Buffer size on demand.
				var newBuf = new byte[this.bufferLength * 2];
				Array.Copy(this.byteBuffer, newBuf, this.bufferLength);
					this.byteBuffer = newBuf;
				free = this.bufferLength;
			}

			var read = this.stream.Read(this.byteBuffer, this.bufferLength, free);
			if (read > 0)
			{
					this.inputStreamLength = this.bufferLength = this.bufferLength + read;
				return read;
			}

			// end of stream reached
			return 0;
		}
	}

	/// <summary>
	/// A buffer that supports UTF-8 encoding.
	/// </summary>
	[GeneratedCode("CoCo/R", "0.1")]
	internal class UTF8Buffer: Buffer 
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="Buffer" /> class.
		/// </summary>
		/// <param name="b">
		/// The buffer to base this UTF-8 Buffer on.
		/// </param>
		public UTF8Buffer(Buffer b): base(b) {}
		
		/// <summary>
		/// Reads a character from the buffer and moves the buffer pointer.
		/// </summary>
		/// <returns>
		///	The character.
		/// </returns>
		public override int Read() {
			int ch;
			do {
				ch = base.Read();
				// until we find a utf8 start (0xxxxxxx or 11xxxxxx)
			} while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != Eof));
			if (ch < 128 || ch == Eof) {
				// nothing to do, first 127 chars are the same in ascii and utf8
				// 0xxxxxxx or end of file character
			} else if ((ch & 0xF0) == 0xF0) {
				// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
				int c1 = ch & 0x07; ch = base.Read();
				int c2 = ch & 0x3F; ch = base.Read();
				int c3 = ch & 0x3F; ch = base.Read();
				int c4 = ch & 0x3F;
				ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
			} else if ((ch & 0xE0) == 0xE0) {
				// 1110xxxx 10xxxxxx 10xxxxxx
				int c1 = ch & 0x0F; ch = base.Read();
				int c2 = ch & 0x3F; ch = base.Read();
				int c3 = ch & 0x3F;
				ch = (((c1 << 6) | c2) << 6) | c3;
			} else if ((ch & 0xC0) == 0xC0) {
				// 110xxxxx 10xxxxxx
				int c1 = ch & 0x1F; ch = base.Read();
				int c2 = ch & 0x3F;
				ch = (c1 << 6) | c2;
			}
			return ch;
		}
	}


/// <summary>
/// The scanner.
/// </summary>
[GeneratedCode("CoCo/R", "0.1")]
internal class Scanner {
	/// <summary>
	/// The end-of-line character.
	/// </summary>
	private const char EndOfLine = '\n';
	
	/// <summary>
	/// The end-of-file symbol.
	/// </summary>
	private const int EofSymbol = 0; 

	/// <summary>
	/// Maps first token character to start state.
	/// </summary>
	private static readonly Dictionary<int, int> Start; 

-->declarations

	/// <summary>
	/// The current token.
	/// </summary>
	private Token t;
	
	/// <summary>
	/// The token index.
	/// </summary>
	private int index = 0;
	
	/// <summary>
	/// The current input character.
	/// </summary>
	private int ch;
	
	/// <summary>
	/// The byte position of current character.
	/// </summary>
	private int pos;
	
	/// <summary>
	/// The position by unicode characters starting with 0.
	/// </summary>
	private int charPos;
	
	/// <summary>
	/// The column number of current character.
	/// </summary>
	private int col;
	
	/// <summary>
	/// The line number of current character.
	/// </summary>
	private int line;
	
	/// <summary>
	/// EOLs that appeared in a comment.
	/// </summary>
	private int oldEols;      

	/// <summary>
	/// The list of tokens already peeked (first token is a dummy).
	/// </summary>
	private Token tokens;
	
	/// <summary>
	/// The current peek token.
	/// </summary>
	private Token pt;
	
	/// <summary>
	/// The text of current token.
	/// </summary>
	private char[] tval = new char[128]; // 
	
	/// <summary>
	/// The length of current token.
	/// </summary>
	private int tlen;
	
	/// <summary>
	/// Initializes the static state of the <see cref="Scanner" /> class.
	/// </summary>
	static Scanner() {
		Start = new Dictionary<int, int>(128);
-->initialization 
	} 
	
	/// <summary>
	/// Initializes a new instance of the <see cref="Scanner" /> class.
	/// </summary>
	/// <param name="s">
	/// The stream to scan for tokens.
	/// </param>
	public Scanner (Stream s) {
		this.Buffer = new Buffer(s, true);
		Init();
	}

	/// <summary>
	/// Gets or sets the scanner buffer.
	/// </summary>
	public Buffer Buffer { get; set; } 
	
	/// <summary>
	/// Gets or sets indicating whether to emit comments.
	/// </summary>
	public bool EmitComments { get; set; }
	 
	/// <summary>
	/// Gets the current token.
	/// </summary>
	public Token Current { get { return this.t; } }

	/// <summary>
	/// Initializes the scanner.
	/// </summary>
	void Init() {
		pos = -1; line = 1; col = 0; charPos = -1;
		oldEols = 0;
		NextCh();
		if (ch == 0xEF) { // check optional byte order mark for UTF-8
			NextCh(); int ch1 = ch;
			NextCh(); int ch2 = ch;
			if (ch1 != 0xBB || ch2 != 0xBF) {
				throw new FatalError(String.Format("illegal byte order mark: EF {0,2:X} {1,2:X}", ch1, ch2));
			}
			Buffer = new UTF8Buffer(Buffer); col = 0; charPos = -1;
			NextCh();
		}
		else {
			Buffer = new UTF8Buffer(Buffer); 
		}
		pt = tokens = new Token();  // first token is a dummy
	}
	
	/// <summary>
	/// Retrieves the next character.
	/// </summary>
	void NextCh() {
		if (oldEols > 0) { ch = EndOfLine; oldEols--; } 
		else {
			pos = Buffer.Pos;
			// Buffer reads unicode chars, if UTF8 has been detected
			ch = Buffer.Read(); col++; charPos++;
			// replace isolated '\r' by '\n' in order to make
			// eol handling uniform across Windows, Unix and Mac
			if (ch == '\r' && Buffer.Peek() != '\n') ch = EndOfLine;
			if (ch == EndOfLine) { line++; col = 0; }
		}
-->casing1
	}

	/// <summary>
	/// Adds a character to the current token.
	/// </summary>
	void AddCh() {
		if (tlen >= tval.Length) {
			char[] newBuf = new char[2 * tval.Length];
			Array.Copy(tval, 0, newBuf, 0, tval.Length);
			tval = newBuf;
		}
		if (ch != Buffer.Eof) {
-->casing2
			NextCh();
		}
	}

-->comments

	/// <summary>
	/// Checks for literals.
	/// </summary>
	void CheckLiteral() {
-->literals
	}

	/// <summary>
	/// Gets the next token.
	/// </summary>
	/// <returns>
	/// The token.
	/// </returns>
	Token NextToken() {
		while (ch == ' ' ||
-->scan1
		) NextCh();
-->scan2
		int recKind = NoSymbol;
		int recEnd = pos;
		t = new Token();
		t.IsComment = false; t.Pos = pos; t.Col = col; t.Line = line; t.CharPos = charPos;
		int state;
		state = Start.ContainsKey(ch) ? Start[ch] : 0;
		tlen = 0; AddCh();
		
		switch (state) {
			case -1: { t.Kind = EofSymbol; break; } // NextCh already done
			case 0: {
				if (recKind != NoSymbol) {
					tlen = recEnd - t.Pos;
					SetScannerBehindT();
				}
				t.Kind = recKind; break;
			} // NextCh already done
-->scan3
		}
		t.Val = new String(tval, 0, tlen);
		return t;
	}
	
	/// <summary>
	/// Positions the scannert to after the currenttoken.
	/// </summary>
	private void SetScannerBehindT() {
		Buffer.Pos = t.Pos;
		NextCh();
		line = t.Line; col = t.Col; charPos = t.CharPos;
		for (int i = 0; i < tlen; i++) NextCh();
	}
	
	/// <summary>
	/// Gets the next token (possibly a token already seen during peeking)
	/// </summary>
	/// <returns>
	/// The token.
	/// </returns>
	public Token Scan () {
		Token result;
		if (tokens.Next == null) {
			result = NextToken();
			result.Index = ++index;
		} else {
			pt = tokens = tokens.Next;
			result = tokens;
		}

		return result;
	}

	/// <summary>
	/// Peeks for the next token, ignore pragmas.
	/// </summary>
	/// <returns>
	/// The next token.
	/// </returns>
	public Token Peek () {
		do {
			if (pt.Next == null) {
				pt.Next = NextToken();
			}
			pt = pt.Next;
		} while (pt.Kind > MaxToken); // skip pragmas
		
		pt.Index = ++index;
		return pt;
	}

	/// <summary>
	/// make sure that peeking starts at the current scan position
	/// </summary>
	public void ResetPeek () 
	{ 
		pt = tokens; 
	}
} 
