// <auto-generated />
namespace ConnectQl.Internal
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using ConnectQl.Internal.Ast;
    using ConnectQl.Internal.Ast.Expressions;
    using ConnectQl.Internal.Ast.Sources;
    using ConnectQl.Internal.Ast.Statements;
    using ConnectQl.Internal.Ast.Targets;
    using ConnectQl.Internal.Interfaces;
    using ConnectQl.Results;

    /// <summary>
    /// Event arguments for the <see cref="Parser.TokenScanned" /> event.
    /// </summary>
    internal class TokenScannedEventArgs : EventArgs
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TokenScannedEventArgs" /> class.
        /// </summary>
        public TokenScannedEventArgs(Token token)
        {
            this.Token = token;
        }

        /// <summary>
        /// Gets the token.
        /// </summary>
        public Token Token { get; }
    }

    /// <summary>
    /// The parser.
    /// </summary>
    [GeneratedCode("CoCo/R", "0.1")]
    internal partial class Parser
    {

        /// <summary>
        /// The EOF symbol.
        /// </summary>
        public const int EOFSymbol = 0;

        /// <summary>
        /// The String symbol.
        /// </summary>
        public const int StringSymbol = 1;

        /// <summary>
        /// The Number symbol.
        /// </summary>
        public const int NumberSymbol = 2;

        /// <summary>
        /// The Bracketedidentifier symbol.
        /// </summary>
        public const int BracketedidentifierSymbol = 3;

        /// <summary>
        /// The Identifier symbol.
        /// </summary>
        public const int IdentifierSymbol = 4;

        /// <summary>
        /// The Variable symbol.
        /// </summary>
        public const int VariableSymbol = 5;

        /// <summary>
        /// The Comment0 symbol.
        /// </summary>
        public const int Comment0Symbol = 6;

        /// <summary>
        /// The Comment1 symbol.
        /// </summary>
        public const int Comment1Symbol = 7;

        /// <summary>
        /// The Comment2 symbol.
        /// </summary>
        public const int Comment2Symbol = 8;

        /// <summary>
        /// The maximum token.
        /// </summary>
        public const int MaxToken = 67;
        /// <summary>
        /// The minimum distance between two errors.
        /// </summary>
        private const int MinimumErrDistance = 2;

        /// <summary>
        /// The node data provider.
        /// </summary>
        private readonly INodeDataProvider data;

        /// <summary>
        /// The scanner.
        /// </summary>
        private readonly Scanner scanner;

        /// <summary>
        /// The error writer.
        /// </summary>
        private readonly ErrorWriter errors;

        /// <summary>
        /// The last recognized token.
        /// </summary>
        private Token t;

        /// <summary>
        /// The distance from the last error.
        /// </summary>
        private int errDist = MinimumErrDistance;
        /// <summary>
        /// Initializes a new instance of the <see cref="Parser"/> class.
        /// </summary>
        /// <param name="scanner">
        /// The scanner.
        /// </param>
        /// <param name="data">
        /// The data provider.
        /// </param>
        /// <param name="messages">
        /// The message writer.
        /// </param>
        public Parser(Scanner scanner, INodeDataProvider data, IMessageWriter messages)
        {
            this.scanner = scanner;
            this.data = data;
            this.errors = new ErrorWriter(messages);
        }

        /// <summary>
        /// Raised when a token is scanned.
        /// </summary>
        public event EventHandler<TokenScannedEventArgs> TokenScanned;

        /// <summary>
        /// Gets the tokens.
        /// </summary>
        public IList<Token> Tokens { get; } = new List<Token>();

        /// <summary>
        /// Gets the statements that this parser generated.
        /// </summary>
        public List<StatementBase> Statements { get; private set; }

        /// <summary>
        /// Gets the look-ahead token.
        /// </summary>
        private Token LookAhead { get; set; }

        /// <summary>
        /// Triggers a semantic error.
        /// </summary>
        /// <param name="lineFrom">
        /// The line number from.
        /// </param>
        /// <param name="lineTo">
        /// The line number to.
        /// </param>
        /// <param name="colTo">
        /// The column number to.
        /// </param>
        /// <param name="tokenIndexFrom">
        /// The token index from.
        /// </param>
        /// <param name="tokenIndexTo">
        /// The token index to.
        /// </param>
        /// <param name="colFrom">
        /// The column number from.
        /// </param>
        /// <param name="msg">
        /// The message.
        /// </param>
        public void SemErr(int lineFrom, int colFrom, int tokenIndexFrom, int lineTo, int colTo, int tokenIndexTo, string msg)
        {
            if (this.errDist >= MinimumErrDistance)
            {
                this.errors.SemErr(lineFrom, colFrom, tokenIndexFrom, lineTo, colTo, tokenIndexTo, msg);
            }

            this.errDist = 0;
        }

        /// <summary>
        /// Triggers a semantic error.
        /// </summary>
        /// <param name="msg">
        /// The message.
        /// </param>
        public void SemErr(string msg)
        {
            if (this.errDist >= MinimumErrDistance)
            {
                this.errors.SemErr(t.Line, t.Col, t.Index - 2, t.Line, t.Col + t.Val.Length, t.Index - 2, msg);
            }

            this.errDist = 0;
        }

        /// <summary>
        /// Triggers a syntactic error.
        /// </summary>
        /// <param name="n">
        /// The error number.
        /// </param>
        private void SynErr(int n)
        {
            if (this.errDist >= MinimumErrDistance)
            {
                this.errors.SynErr(this.LookAhead.Line, this.LookAhead.Col, this.LookAhead.Index - 1, n);
            }

            this.errDist = 0;
        }

        /// <summary>
        /// Gets the next token.
        /// </summary>
        private void Get()
        {
            for (; ; )
            {
                t = this.LookAhead;
                this.TokenScanned?.Invoke(this, new TokenScannedEventArgs(this.LookAhead));
                this.LookAhead = this.scanner.Scan();

                Tokens.Add(this.LookAhead);

                if (this.LookAhead.IsComment)
                {
                    this.LookAhead = t;
                    continue;
                }

                if (this.LookAhead.Kind <= MaxToken) { ++this.errDist; break; }

                this.LookAhead = t;
            }
        }

        /// <summary>
        /// Expects that the next token is the specified token.
        /// </summary>
        /// <param name="n">
        /// The token to expect.
        /// </param>
        private void Expect(int n)
        {
            if (this.LookAhead.Kind == n)
            {
                Get();
            }
            else
            {
                SynErr(n);
            }
        }

        /// <summary>
        /// Checks if the next token is the start of the specifed set.
        /// </summary>
        /// <param name="s">
        /// The set number.
        /// </param>
        /// <returns>
        /// <c>true</c> if the token is the start of the set.
        /// </returns>
        private bool StartOf(int s)
        {
            return Set[s, this.LookAhead.Kind];
        }

        /// <summary>
        /// Expects that the next token is the specified token but keeps scanning if it wasn't found.
        /// </summary>
        /// <param name="n">
        /// The token to expect.
        /// </param>
        /// <param name="follow">
        /// The token that follows.
        /// </param>
        private void ExpectWeak(int n, int follow)
        {
            if (this.LookAhead.Kind == n) Get();
            else
            {
                SynErr(n);
                while (!StartOf(follow)) Get();
            }
        }

        /// <summary>
        /// Tries to get the next token even if the separator is missing.
        /// </summary>
        /// <param name="n">
        /// The token number that specified the separator.
        /// </param>
        /// <param name="syFol">
        /// The symbol after the separator.
        /// </param>
        /// <param name="repFol">
        /// The symbol that ends the separated symbols.
        /// </param>
        /// <returns>
        /// <c>true</c> if the separator and symbol were found, false otherwise.
        /// </returns>
        private bool WeakSeparator(int n, int syFol, int repFol)
        {
            int kind = this.LookAhead.Kind;
            if (kind == n) { Get(); return true; }
            else if (StartOf(repFol)) { return false; }
            else
            {
                SynErr(n);
                while (!(Set[syFol, kind] || Set[repFol, kind] || Set[0, kind]))
                {
                    Get();
                    kind = this.LookAhead.Kind;
                }
                return StartOf(syFol);
            }
        }
        void ConnectQl()
        {
            this.Statements = new List<StatementBase>();
            while (!(StartOf(1))) { SynErr(68); Get(); }
            while (StartOf(2))
            {
                StatementBase statement;
                Statement(out statement);
                this.Statements.Add(statement);
                while (!(StartOf(1))) { SynErr(69); Get(); }
            }
            Expect(0);
        }

        void Statement(out StatementBase statement)
        {
            statement = null; SelectStatement select;
            switch (this.LookAhead.Kind)
            {
                case 13:
                    {
                        DeclareStatement(out statement);
                        break;
                    }
                case 24:
                    {
                        ImportStatement(out statement);
                        break;
                    }
                case 26:
                case 27:
                    {
                        InsertStatement(out statement);
                        break;
                    }
                case 23:
                    {
                        TriggerStatement(out statement);
                        break;
                    }
                case 32:
                    {
                        UnionOrSelectStatement(out select);
                        statement = select;
                        break;
                    }
                case 9:
                    {
                        UseStatement(out statement);
                        break;
                    }
                default: SynErr(70); break;
            }
        }

        void DeclareStatement(out StatementBase statement)
        {
            statement = null; VariableDeclaration variable; FunctionCallSqlExpression function; string jobName = null; var vars = new List<VariableDeclaration>(); var ctx = Mark();
            Expect(13);
            if (this.LookAhead.Kind == 5)
            {
                VariableDeclaration(out variable);
                vars.Add(variable);
                while (this.LookAhead.Kind == 14)
                {
                    Get();
                    VariableDeclaration(out variable);
                    vars.Add(variable);
                }
                statement = this.SetContext(new DeclareStatement(new ReadOnlyCollection<VariableDeclaration>(vars)), ctx);
            }
            else if (this.LookAhead.Kind == 15)
            {
                Get();
                var triggers = new List<Trigger>();
                if (this.LookAhead.Kind == 3 || this.LookAhead.Kind == 4)
                {
                    Name(out jobName);
                }
                else if (this.LookAhead.Kind == 1)
                {
                    String(out jobName);
                }
                else SynErr(71);
                if (this.LookAhead.Kind == 16)
                {
                    TimeSpan interval; string after = null;
                    Get();
                    var triggerCtx = Mark();
                    if (this.LookAhead.Kind == 17)
                    {
                        Get();
                        Interval(out interval);
                        triggers.Add(this.SetContext(new Trigger(interval), triggerCtx));
                    }
                    else if (this.LookAhead.Kind == 18)
                    {
                        Get();
                        if (this.LookAhead.Kind == 3 || this.LookAhead.Kind == 4)
                        {
                            Name(out after);
                        }
                        else if (this.LookAhead.Kind == 1)
                        {
                            String(out after);
                        }
                        else SynErr(72);
                        triggers.Add(this.SetContext(new Trigger(after), triggerCtx));
                    }
                    else if (this.LookAhead.Kind == 19)
                    {
                        Get();
                        Function(out function);
                        triggers.Add(this.SetContext(new Trigger(function), triggerCtx));
                    }
                    else SynErr(73);
                    while (this.LookAhead.Kind == 14 || this.LookAhead.Kind == 20)
                    {
                        if (this.LookAhead.Kind == 20)
                        {
                            Get();
                        }
                        else
                        {
                            Get();
                        }
                        triggerCtx = Mark();
                        if (this.LookAhead.Kind == 17)
                        {
                            Get();
                            Interval(out interval);
                            triggers.Add(this.SetContext(new Trigger(interval), triggerCtx));
                        }
                        else if (this.LookAhead.Kind == 18)
                        {
                            Get();
                            if (this.LookAhead.Kind == 3 || this.LookAhead.Kind == 4)
                            {
                                Name(out after);
                            }
                            else if (this.LookAhead.Kind == 1)
                            {
                                String(out after);
                            }
                            else SynErr(74);
                            triggers.Add(this.SetContext(new Trigger(after), triggerCtx));
                        }
                        else if (this.LookAhead.Kind == 19)
                        {
                            Get();
                            Function(out function);
                            triggers.Add(this.SetContext(new Trigger(function), triggerCtx));
                        }
                        else SynErr(75);
                    }
                }
                Expect(21);
                StatementBase blockStatement; var statements = new List<StatementBase>();
                while (StartOf(2))
                {
                    Statement(out blockStatement);
                    statements.Add(blockStatement);
                }
                Expect(22);
                statement = this.SetContext(new DeclareJobStatement(
                jobName,
                new ReadOnlyCollection<StatementBase>(statements),
                new ReadOnlyCollection<Trigger>(triggers)),
                ctx);
            }
            else SynErr(76);
        }

        void ImportStatement(out StatementBase statement)
        {
            string uri; statement = null; var ctx = Mark();
            Expect(24);
            if (this.LookAhead.Kind == 1)
            {
                String(out uri);
                statement = this.SetContext(new ImportStatement(uri), ctx);
            }
            else if (this.LookAhead.Kind == 25)
            {
                Get();
                String(out uri);
                statement = this.SetContext(new ImportPluginStatement(uri), ctx);
            }
            else SynErr(77);
        }

        void InsertStatement(out StatementBase statement)
        {
            TargetBase target; SelectStatement selectStatement; var ctx = Mark();
            if (this.LookAhead.Kind == 26)
            {
                Get();
            }
            else if (this.LookAhead.Kind == 27)
            {
                Get();
            }
            else SynErr(78);
            var upsert = t.Val.Equals("UPSERT", StringComparison.OrdinalIgnoreCase);
            Expect(28);
            InsertTarget(out target);
            UnionOrSelectStatement(out selectStatement);
            statement = this.SetContext(new InsertStatement(target, upsert, selectStatement), ctx);
        }

        void TriggerStatement(out StatementBase statement)
        {
            string jobName; statement = null; var ctx = Mark();
            Expect(23);
            Expect(15);
            Name(out jobName);
            statement = this.SetContext(new TriggerStatement(jobName), ctx);
        }

        void UnionOrSelectStatement(out SelectStatement statement)
        {
            SelectStatement select; SelectStatement union; var ctx = Mark();
            SelectStatement(out select);
            statement = select;
            if (this.LookAhead.Kind == 29)
            {
                Get();
                if (this.LookAhead.Kind == 32)
                {
                    UnionOrSelectStatement(out union);
                    statement = this.SetContext(new SelectUnionStatement(statement, union), ctx);
                }
                else if (this.LookAhead.Kind == 30)
                {
                    Get();
                    UnionOrSelectStatement(out union);
                    Expect(31);
                    statement = this.SetContext(new SelectUnionStatement(statement, union), ctx);
                }
                else SynErr(79);
            }
        }

        void UseStatement(out StatementBase statement)
        {
            FunctionCallSqlExpression function = null; string functionName = null; var ctx = Mark();
            Expect(9);
            Expect(10);
            Function(out function);
            Expect(11);
            FunctionName(out functionName);
            statement = this.SetContext(new UseStatement(function, functionName), ctx);
        }

        void Function(out FunctionCallSqlExpression function)
        {
            string name; var args = new List<SqlExpressionBase>(); SqlExpressionBase expression; var ctx = Mark();
            Identifier(out name);
            Expect(30);
            if (StartOf(3))
            {
                Expression(out expression);
                args.Add(expression);
                while (this.LookAhead.Kind == 14)
                {
                    Get();
                    Expression(out expression);
                    args.Add(expression);
                }
            }
            Expect(31);
            function = CatchAll(() => this.SetContext(new FunctionCallSqlExpression(name, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx));
        }

        void FunctionName(out string value)
        {
            Expect(4);
            value = t.Val;
        }

        void VariableDeclaration(out VariableDeclaration declaration)
        {
            string VariableSqlExpression; SqlExpressionBase expression; var ctx = Mark();
            Variable(out VariableSqlExpression);
            Expect(12);
            Expression(out expression);
            declaration = this.SetContext(new VariableDeclaration(VariableSqlExpression, expression), ctx);
        }

        void Variable(out string value)
        {
            Expect(5);
            value = t.Val;
        }

        void Expression(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op; var ctx = Mark();
            AndExpression(out expr);
            expression = expr;
            while (this.LookAhead.Kind == 20)
            {
                Get();
                op = t.Val;
                AndExpression(out expr);
                expression = this.SetContext(new BinarySqlExpression(expression, op, expr), ctx);
            }
        }

        void Name(out string value)
        {
            value = null;
            if (this.LookAhead.Kind == 3)
            {
                Get();
                value = t.Val.Substring(1, t.Val.Length - 2);
            }
            else if (this.LookAhead.Kind == 4)
            {
                Get();
                value = t.Val;
            }
            else SynErr(80);
        }

        void String(out string value)
        {
            Expect(1);
            value = ParseString(t.Val);
        }

        void Interval(out TimeSpan interval)
        {
            object numberValue; string duration; var ctx = Mark();
            Number(out numberValue);
            Identifier(out duration);
            interval = ParseTimeSpan(duration, numberValue);
        }

        void Number(out object value)
        {
            Expect(2);
            value = ParseNumber(t.Val);
        }

        void Identifier(out string value)
        {
            Expect(4);
            value = t.Val;
        }

        void InsertTarget(out TargetBase target)
        {
            string name; target = null; var ctx = Mark(); string variable;
            if (this.LookAhead.Kind == 5)
            {
                Variable(out variable);
                target = CatchAll(() => this.SetContext(new VariableTarget(variable), ctx));
            }
            else if (this.LookAhead.Kind == 4)
            {
                Identifier(out name);
                if (this.LookAhead.Kind == 30)
                {
                    var args = new List<SqlExpressionBase>(); SqlExpressionBase e;
                    Get();
                    if (StartOf(3))
                    {
                        Expression(out e);
                        args.Add(e);
                        while (this.LookAhead.Kind == 14)
                        {
                            Get();
                            Expression(out e);
                            args.Add(e);
                        }
                    }
                    Expect(31);
                    target = CatchAll(() => this.SetContext(new FunctionTarget(this.SetContext(new FunctionCallSqlExpression(name, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx)), ctx));
                }
                if (target == null)
                {
                    var args = new[] { this.SetContext(new ConstSqlExpression(name), ctx) };
                    target = CatchAll(() => this.SetContext(new FunctionTarget(this.SetContext(new FunctionCallSqlExpression(name, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx)), ctx));
                }

            }
            else SynErr(81);
        }

        void SelectStatement(out SelectStatement query)
        {
            query = null;
            SourceBase source, join = null;
            AliasedSqlExpression aliasedExpression;
            SqlExpressionBase expression, where = null, having = null;
            OrderBySqlExpression orderBy = null;
            var expressions = new List<AliasedSqlExpression>();
            var groups = new List<SqlExpressionBase>();
            var orders = new List<OrderBySqlExpression>();
            var ctx = Mark();
            Expect(32);
            ExpressionAlias(out aliasedExpression);
            expressions.Add(aliasedExpression);
            while (WeakSeparator(14, 3, 4))
            {
                ExpressionAlias(out aliasedExpression);
                expressions.Add(aliasedExpression);
            }
            Expect(33);
            Join(out source);
            while (WeakSeparator(14, 5, 6))
            {
                Join(out join);
                source = new JoinSource(JoinType.Cross, source, join);
            }
            if (this.LookAhead.Kind == 34)
            {
                Get();
                Expression(out where);
            }
            if (this.LookAhead.Kind == 35)
            {
                Get();
                Expect(19);
                Expression(out expression);
                groups.Add(expression);
                while (WeakSeparator(14, 3, 7))
                {
                    Expression(out expression);
                    groups.Add(expression);
                }
                if (this.LookAhead.Kind == 36)
                {
                    Get();
                    Expression(out having);
                }
            }
            if (this.LookAhead.Kind == 37)
            {
                Get();
                Expect(19);
                OrderBySqlExpression(out orderBy);
                orders.Add(orderBy);
                while (WeakSeparator(14, 3, 8))
                {
                    OrderBySqlExpression(out orderBy);
                    orders.Add(orderBy);
                }
            }
            query = this.SetContext(new SelectFromStatement(
            new ReadOnlyCollection<AliasedSqlExpression>(expressions),
            source,
            where,
            new ReadOnlyCollection<SqlExpressionBase>(groups),
            having,
            new ReadOnlyCollection<OrderBySqlExpression>(orders)),
            ctx);
        }

        void ExpressionAlias(out AliasedSqlExpression aliased)
        {
            string alias = null; SqlExpressionBase expression; var ctx = Mark();
            Expression(out expression);
            if (this.LookAhead.Kind == 48)
            {
                Get();
                Name(out alias);
            }
            aliased = this.SetContext(new AliasedSqlExpression(expression, alias), ctx);
        }

        void Join(out SourceBase source)
        {
            SourceBase join = null;
            SqlExpressionBase expression;
            var ctx = Mark();
            JoinType joinType;
            SourceSelector(out source);
            while (StartOf(9))
            {
                if (this.LookAhead.Kind == 40 || this.LookAhead.Kind == 41 || this.LookAhead.Kind == 42)
                {
                    if (this.LookAhead.Kind == 40)
                    {
                        Get();
                        joinType = JoinType.Inner;
                    }
                    else if (this.LookAhead.Kind == 41)
                    {
                        Get();
                        Expect(40);
                        joinType = JoinType.Inner;
                    }
                    else
                    {
                        Get();
                        Expect(40);
                        joinType = JoinType.Left;
                    }
                    SourceSelector(out join);
                    Expect(43);
                    Expression(out expression);
                    source = this.SetContext(new JoinSource(joinType, source, join, expression), ctx);
                }
                else if (this.LookAhead.Kind == 44)
                {
                    Get();
                    if (this.LookAhead.Kind == 40)
                    {
                        Get();
                        SourceSelector(out join);
                        source = this.SetContext(new JoinSource(JoinType.Cross, source, join), ctx);
                    }
                    else if (this.LookAhead.Kind == 45)
                    {
                        Get();
                        SourceSelector(out join);
                        source = this.SetContext(new ApplySource(source, join, false), ctx);
                    }
                    else SynErr(82);
                }
                else if (this.LookAhead.Kind == 46)
                {
                    Get();
                    Expect(45);
                    SourceSelector(out join);
                    source = this.SetContext(new ApplySource(source, join, true), ctx);
                }
                else
                {
                    Get();
                    joinType = JoinType.SequentialInner;
                    if (this.LookAhead.Kind == 41 || this.LookAhead.Kind == 42)
                    {
                        if (this.LookAhead.Kind == 41)
                        {
                            Get();
                        }
                        else
                        {
                            Get();
                            joinType = JoinType.SequentialLeft;
                        }
                    }
                    Expect(40);
                    SourceSelector(out join);
                    source = this.SetContext(new JoinSource(joinType, source, join), ctx);
                }
            }
        }

        void OrderBySqlExpression(out OrderBySqlExpression orderBy)
        {
            SqlExpressionBase expression;
            var ascending = true;
            var ctx = Mark();
            Expression(out expression);
            if (this.LookAhead.Kind == 38 || this.LookAhead.Kind == 39)
            {
                if (this.LookAhead.Kind == 38)
                {
                    Get();
                }
                else
                {
                    Get();
                    ascending = false;
                }
            }
            orderBy = this.SetContext(new OrderBySqlExpression(expression, ascending), ctx);
        }

        void SourceSelector(out SourceBase source)
        {
            string name;
            source = null;
            SourceBase alias;
            SelectStatement select;
            var ctx = Mark();
            if (this.LookAhead.Kind == 4 || this.LookAhead.Kind == 5)
            {
                SourceBase(out alias);
                source = alias;
            }
            else if (this.LookAhead.Kind == 30)
            {
                Get();
                if (this.LookAhead.Kind == 4 || this.LookAhead.Kind == 5 || this.LookAhead.Kind == 30)
                {
                    Join(out source);
                    Expect(31);
                }
                else if (this.LookAhead.Kind == 32)
                {
                    UnionOrSelectStatement(out select);
                    Expect(31);
                    Name(out name);
                    source = this.SetContext(new SelectSource(select, name), ctx);
                }
                else SynErr(83);
            }
            else SynErr(84);
        }

        void SourceBase(out SourceBase source)
        {
            string name, alias = null; source = null; FunctionCallSqlExpression function = null; var ctx = Mark(); string variable;
            if (this.LookAhead.Kind == 5)
            {
                Variable(out variable);
                if (this.LookAhead.Kind == 48)
                {
                    Get();
                }
                Name(out alias);
                source = CatchAll(() => this.SetContext(new VariableSource(variable, alias), ctx));
            }
            else if (this.LookAhead.Kind == 4)
            {
                Identifier(out name);
                if (StartOf(10))
                {
                    if (this.LookAhead.Kind == 30)
                    {
                        var args = new List<SqlExpressionBase>(); SqlExpressionBase e;
                        Get();
                        if (StartOf(3))
                        {
                            Expression(out e);
                            args.Add(e);
                            while (this.LookAhead.Kind == 14)
                            {
                                Get();
                                Expression(out e);
                                args.Add(e);
                            }
                        }
                        Expect(31);
                        function = this.SetContext(new FunctionCallSqlExpression(name, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx);
                        if (this.LookAhead.Kind == 48)
                        {
                            Get();
                        }
                        Name(out alias);
                        source = CatchAll(() => this.SetContext(new FunctionSource(function, alias), ctx));
                    }
                    else
                    {
                        var args = new SqlExpressionBase[] { this.SetContext(new ConstSqlExpression(name), ctx) };
                        function = this.SetContext(new FunctionCallSqlExpression(this.DefaultProvider, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx);

                        if (this.LookAhead.Kind == 48)
                        {
                            Get();
                        }
                        Name(out alias);
                    }
                }
                if (source == null)
                {
                    var args = new[] { this.SetContext(new ConstSqlExpression(name), ctx) };
                    function = function ?? this.SetContext(new FunctionCallSqlExpression(this.DefaultProvider, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx);
                    source = CatchAll(() => this.SetContext(new FunctionSource(function, alias ?? name), ctx));
                }

            }
            else SynErr(85);
        }

        void AndExpression(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op; var ctx = Mark();
            NegateExpression(out expr);
            expression = expr;
            while (this.LookAhead.Kind == 49)
            {
                Get();
                op = t.Val;
                NegateExpression(out expr);
                expression = this.SetContext(new BinarySqlExpression(expression, op, expr), ctx);
            }
        }

        void NegateExpression(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op = null; var ctx = Mark();
            if (this.LookAhead.Kind == 50)
            {
                Get();
                op = t.Val;
            }
            CompareExpression(out expr);
            expression = op == null ? expr : this.SetContext(new UnarySqlExpression(op, expr), ctx);
        }

        void CompareExpression(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op; var ctx = Mark();
            AddExpression(out expr);
            expression = expr;
            while (StartOf(11))
            {
                switch (this.LookAhead.Kind)
                {
                    case 51:
                        {
                            Get();
                            break;
                        }
                    case 52:
                        {
                            Get();
                            break;
                        }
                    case 12:
                        {
                            Get();
                            break;
                        }
                    case 53:
                        {
                            Get();
                            break;
                        }
                    case 54:
                        {
                            Get();
                            break;
                        }
                    case 55:
                        {
                            Get();
                            break;
                        }
                }
                op = t.Val;
                AddExpression(out expr);
                expression = this.SetContext(new BinarySqlExpression(expression, op, expr), ctx);
            }
        }

        void AddExpression(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op; var ctx = Mark();
            MulExpression(out expr);
            expression = expr;
            while (this.LookAhead.Kind == 56 || this.LookAhead.Kind == 57)
            {
                if (this.LookAhead.Kind == 56)
                {
                    Get();
                }
                else
                {
                    Get();
                }
                op = t.Val;
                MulExpression(out expr);
                expression = this.SetContext(new BinarySqlExpression(expression, op, expr), ctx);
            }
        }

        void MulExpression(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op; var ctx = Mark();
            Unary(out expr);
            expression = expr;
            while (StartOf(12))
            {
                if (this.LookAhead.Kind == 58)
                {
                    Get();
                }
                else if (this.LookAhead.Kind == 59)
                {
                    Get();
                }
                else if (this.LookAhead.Kind == 60)
                {
                    Get();
                }
                else
                {
                    Get();
                }
                op = t.Val;
                Unary(out expr);
                expression = this.SetContext(new BinarySqlExpression(expression, op, expr), ctx);
            }
        }

        void Unary(out SqlExpressionBase expression)
        {
            SqlExpressionBase expr; string op = null; var ctx = Mark();
            if (this.LookAhead.Kind == 56 || this.LookAhead.Kind == 57 || this.LookAhead.Kind == 62)
            {
                if (this.LookAhead.Kind == 56)
                {
                    Get();
                }
                else if (this.LookAhead.Kind == 57)
                {
                    Get();
                }
                else
                {
                    Get();
                }
                op = t.Val;
            }
            ValueExpression(out expr);
            expression = op == null ? expr : this.SetContext(new UnarySqlExpression(op, expr), ctx);
        }

        void ValueExpression(out SqlExpressionBase expression)
        {
            string stringValue; object numberValue; SqlExpressionBase function; expression = null; string VariableSqlExpression; var ctx = Mark();
            switch (this.LookAhead.Kind)
            {
                case 1:
                    {
                        String(out stringValue);
                        expression = this.SetContext(new ConstSqlExpression(stringValue), ctx);
                        break;
                    }
                case 2:
                    {
                        Number(out numberValue);
                        if (this.LookAhead.Kind == 4)
                        {
                            string duration;
                            Identifier(out duration);
                            expression = this.SetContext(new ConstSqlExpression(ParseTimeSpan(duration, numberValue)), ctx);
                        }
                        expression = expression ?? this.SetContext(new ConstSqlExpression(numberValue), ctx);
                        break;
                    }
                case 30:
                    {
                        Get();
                        Expression(out expression);
                        Expect(31);
                        break;
                    }
                case 63:
                    {
                        Get();
                        expression = this.SetContext(new ConstSqlExpression(true), ctx);
                        break;
                    }
                case 64:
                    {
                        Get();
                        expression = this.SetContext(new ConstSqlExpression(false), ctx);
                        break;
                    }
                case 65:
                    {
                        Get();
                        expression = this.SetContext(new ConstSqlExpression(null), ctx);
                        break;
                    }
                case 3:
                case 4:
                case 58:
                    {
                        FieldOrFunction(out function);
                        expression = function;
                        break;
                    }
                case 5:
                    {
                        Variable(out VariableSqlExpression);
                        expression = this.SetContext(new VariableSqlExpression(VariableSqlExpression), ctx);
                        break;
                    }
                default: SynErr(86); break;
            }
        }

        void FieldOrFunction(out SqlExpressionBase field)
        {
            string first, second = null; field = null; var args = new List<SqlExpressionBase>(); SqlExpressionBase expression; var ctx = Mark();
            if (this.LookAhead.Kind == 4)
            {
                Identifier(out first);
                if (StartOf(13))
                {
                    if (this.LookAhead.Kind == 66)
                    {
                        Get();
                        if (this.LookAhead.Kind == 4)
                        {
                            Identifier(out second);
                        }
                        else if (this.LookAhead.Kind == 3)
                        {
                            BracketedIdentifier(out second);
                        }
                        else if (this.LookAhead.Kind == 58)
                        {
                            WildCard(out second);
                        }
                        else SynErr(87);
                    }
                    field = second == null
                    ? this.SetContext(new FieldReferenceSqlExpression(first), ctx)
                    : second == "*"
                    ? (SqlExpressionBase)this.SetContext(new WildcardSqlExpression(first), ctx)
                    : this.SetContext(new FieldReferenceSqlExpression(first, second), ctx);
                }
                else if (this.LookAhead.Kind == 30)
                {
                    Get();
                    if (StartOf(3))
                    {
                        Expression(out expression);
                        args.Add(expression);
                        while (this.LookAhead.Kind == 14)
                        {
                            Get();
                            Expression(out expression);
                            args.Add(expression);
                        }
                    }
                    Expect(31);
                    field = CatchAll(() => this.SetContext(new FunctionCallSqlExpression(first, new ReadOnlyCollection<SqlExpressionBase>(args)), ctx));
                }
                else SynErr(88);
            }
            else if (this.LookAhead.Kind == 3)
            {
                BracketedIdentifier(out first);
                if (this.LookAhead.Kind == 66)
                {
                    Get();
                    if (this.LookAhead.Kind == 4)
                    {
                        Identifier(out second);
                    }
                    else if (this.LookAhead.Kind == 3)
                    {
                        BracketedIdentifier(out second);
                    }
                    else SynErr(89);
                }
                field = this.SetContext(second == null ? new FieldReferenceSqlExpression(first) : new FieldReferenceSqlExpression(first, second), ctx);
            }
            else if (this.LookAhead.Kind == 58)
            {
                WildCard(out first);
                field = this.SetContext(new WildcardSqlExpression(null), ctx);
            }
            else SynErr(90);
        }

        void WildCard(out string value)
        {
            Expect(58);
            value = t.Val;
        }

        void BracketedIdentifier(out string value)
        {
            Expect(3);
            value = t.Val.Substring(1, t.Val.Length - 2);
        }
        /// <summary>
        /// Parses the text.
        /// </summary>
        public void Parse()
        {
            this.LookAhead = new Token();
            this.LookAhead.Val = "";
            Get();
            ConnectQl();
            Expect(0);

        }

        /// <summary>
        /// The initialization set.
        /// </summary>
        private static readonly bool[,] Set = {
        {true,false,false,false,false,false,false,false,false,true,false,false,false,true,false,false,false,false,false,false,false,false,false,true,true,false,true,true,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {true,false,false,false,false,false,false,false,false,true,false,false,false,true,false,false,false,false,false,false,false,false,false,true,true,false,true,true,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,false,false,false,false,false,false,false,false,true,false,false,false,true,false,false,false,false,false,false,false,false,false,true,true,false,true,true,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,true,true,true,false,false,false,true,true,true,true,false,false,false},
        {false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,false,false,false,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {true,false,false,false,false,false,false,false,false,true,false,false,false,true,false,false,false,false,false,false,false,false,true,true,true,false,true,true,false,true,false,true,true,false,true,true,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {true,false,false,false,false,false,false,false,false,true,false,false,false,true,false,false,false,false,false,false,false,false,true,true,true,false,true,true,false,true,false,true,true,false,false,false,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {true,false,false,false,false,false,false,false,false,true,false,false,false,true,false,false,false,false,false,false,false,false,true,true,true,false,true,true,false,true,false,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,true,true,false,true,false,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,false,false,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,true,true,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false},
        {false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,true,true,true,false,false,false,false,false,false,false},
        {true,false,false,false,false,false,false,false,false,true,false,false,true,true,true,false,false,false,false,false,true,false,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false,true,false,false}

    };
    }

    /// <summary>
    /// The error writer.
    /// </summary>
    [GeneratedCode("CoCo/R", "0.1")]
    internal class ErrorWriter
    {
        /// <summary>
        /// The message writer to write to.
        /// </summary>
        private readonly IMessageWriter result;

        /// <summary>
        /// Initializes a new instance of the <see cref="ErrorWriter" /> class.
        /// </summary>
        /// <param name="result">
        /// The message writer to write to.
        /// </param>
        public ErrorWriter(IMessageWriter result)
        {
            this.result = result;
        }

        /// <summary>
        /// Writes a syntax error to the message writer.
        /// </summary>
        /// <param name="line">
        /// The line number where the error occured.
        /// </param>
        /// <param name="col">
        /// The column number where the error occured.
        /// </param>
        /// <param name="index">
        /// The index of the token.
        /// </param>
        /// <param name="n">
        /// The error number.
        /// </param>
        public virtual void SynErr(int line, int col, int index, int n)
        {
            string s;
            switch (n)
            {
                case 0: s = "EOF expected"; break;
                case 1: s = "string expected"; break;
                case 2: s = "number expected"; break;
                case 3: s = "bracketedidentifier expected"; break;
                case 4: s = "identifier expected"; break;
                case 5: s = "variable expected"; break;
                case 6: s = "Comment0 expected"; break;
                case 7: s = "Comment1 expected"; break;
                case 8: s = "Comment2 expected"; break;
                case 9: s = "\"use\" expected"; break;
                case 10: s = "\"default\" expected"; break;
                case 11: s = "\"for\" expected"; break;
                case 12: s = "\"=\" expected"; break;
                case 13: s = "\"declare\" expected"; break;
                case 14: s = "\",\" expected"; break;
                case 15: s = "\"job\" expected"; break;
                case 16: s = "\"triggered\" expected"; break;
                case 17: s = "\"every\" expected"; break;
                case 18: s = "\"after\" expected"; break;
                case 19: s = "\"by\" expected"; break;
                case 20: s = "\"or\" expected"; break;
                case 21: s = "\"begin\" expected"; break;
                case 22: s = "\"end\" expected"; break;
                case 23: s = "\"trigger\" expected"; break;
                case 24: s = "\"import\" expected"; break;
                case 25: s = "\"plugin\" expected"; break;
                case 26: s = "\"insert\" expected"; break;
                case 27: s = "\"upsert\" expected"; break;
                case 28: s = "\"into\" expected"; break;
                case 29: s = "\"union\" expected"; break;
                case 30: s = "\"(\" expected"; break;
                case 31: s = "\")\" expected"; break;
                case 32: s = "\"select\" expected"; break;
                case 33: s = "\"from\" expected"; break;
                case 34: s = "\"where\" expected"; break;
                case 35: s = "\"group\" expected"; break;
                case 36: s = "\"having\" expected"; break;
                case 37: s = "\"order\" expected"; break;
                case 38: s = "\"asc\" expected"; break;
                case 39: s = "\"desc\" expected"; break;
                case 40: s = "\"join\" expected"; break;
                case 41: s = "\"inner\" expected"; break;
                case 42: s = "\"left\" expected"; break;
                case 43: s = "\"on\" expected"; break;
                case 44: s = "\"cross\" expected"; break;
                case 45: s = "\"apply\" expected"; break;
                case 46: s = "\"outer\" expected"; break;
                case 47: s = "\"sequential\" expected"; break;
                case 48: s = "\"as\" expected"; break;
                case 49: s = "\"and\" expected"; break;
                case 50: s = "\"not\" expected"; break;
                case 51: s = "\">\" expected"; break;
                case 52: s = "\">=\" expected"; break;
                case 53: s = "\"<=\" expected"; break;
                case 54: s = "\"<\" expected"; break;
                case 55: s = "\"<>\" expected"; break;
                case 56: s = "\"+\" expected"; break;
                case 57: s = "\"-\" expected"; break;
                case 58: s = "\"*\" expected"; break;
                case 59: s = "\"/\" expected"; break;
                case 60: s = "\"%\" expected"; break;
                case 61: s = "\"^\" expected"; break;
                case 62: s = "\"!\" expected"; break;
                case 63: s = "\"true\" expected"; break;
                case 64: s = "\"false\" expected"; break;
                case 65: s = "\"null\" expected"; break;
                case 66: s = "\".\" expected"; break;
                case 67: s = "??? expected"; break;
                case 68: s = "this symbol not expected in ConnectQl"; break;
                case 69: s = "this symbol not expected in ConnectQl"; break;
                case 70: s = "invalid Statement"; break;
                case 71: s = "invalid DeclareStatement"; break;
                case 72: s = "invalid DeclareStatement"; break;
                case 73: s = "invalid DeclareStatement"; break;
                case 74: s = "invalid DeclareStatement"; break;
                case 75: s = "invalid DeclareStatement"; break;
                case 76: s = "invalid DeclareStatement"; break;
                case 77: s = "invalid ImportStatement"; break;
                case 78: s = "invalid InsertStatement"; break;
                case 79: s = "invalid UnionOrSelectStatement"; break;
                case 80: s = "invalid Name"; break;
                case 81: s = "invalid InsertTarget"; break;
                case 82: s = "invalid Join"; break;
                case 83: s = "invalid SourceSelector"; break;
                case 84: s = "invalid SourceSelector"; break;
                case 85: s = "invalid SourceBase"; break;
                case 86: s = "invalid ValueExpression"; break;
                case 87: s = "invalid FieldOrFunction"; break;
                case 88: s = "invalid FieldOrFunction"; break;
                case 89: s = "invalid FieldOrFunction"; break;
                case 90: s = "invalid FieldOrFunction"; break;

                default: s = "error " + n; break;
            }

            this.result.AddError(new Position { Line = line, Column = col, TokenIndex = index }, new Position { Line = line, Column = col, TokenIndex = index }, s);
        }

        /// <summary>
        /// Writes a semantic error to the message writer.
        /// </summary>
        /// <param name="lineFrom">
        /// The line number where the error started.
        /// </param>
        /// <param name="colFrom">
        /// The column number where the error started.
        /// </param>
        /// <param name="tokenIndexFrom">
        /// The token index where the error started.
        /// </param>
        /// <param name="lineTo">
        /// The line number where the error ended.
        /// </param>
        /// <param name="colTo">
        /// The column number where the error ended.
        /// </param>
        /// <param name="tokenIndexTo">
        /// The token index where the error ended.
        /// </param>
        /// <param name="s">
        /// The error message.
        /// </param>
        public virtual void SemErr(int lineFrom, int colFrom, int tokenIndexFrom, int lineTo, int colTo, int tokenIndexTo, string s)
        {
            this.result.AddError(new Position { Line = lineFrom, Column = colFrom, TokenIndex = tokenIndexFrom }, new Position { Line = lineFrom, Column = colFrom, TokenIndex = tokenIndexTo }, s);
        }

        /// <summary>
        /// Writes a semantic error to the message writer without a position.
        /// </summary>
        /// <param name="s">
        /// The error message.
        /// </param>
        public virtual void SemErr(string s)
        {
            this.result.AddError(new Position(), new Position(), s);
        }

        /// <summary>
        /// Writes a warning to the message writer.
        /// </summary>
        /// <param name="lineFrom">
        /// The line number where the error started.
        /// </param>
        /// <param name="colFrom">
        /// The column number where the error started.
        /// </param>
        /// <param name="lineTo">
        /// The line number where the error ended.
        /// </param>
        /// <param name="colTo">
        /// The column number where the error ended.
        /// </param>
        /// <param name="s">
        /// The warning message.
        /// </param>
        public virtual void Warning(int lineFrom, int colFrom, int lineTo, int colTo, string s)
        {
            this.result.AddWarning(new Position { Line = lineFrom, Column = colFrom }, new Position { Line = lineFrom, Column = colFrom }, s);
        }

        /// <summary>
        /// Writes a warning to the message writer without a position.
        /// </summary>
        /// <param name="s">
        /// The warning message.
        /// </param>
        public virtual void Warning(string s)
        {
            this.result.AddWarning(new Position(), new Position(), s);
        }
    }

    /// <summary>
    /// Thrown when a fatal error occurs.
    /// </summary>
    [GeneratedCode("CoCo/R", "0.1")]
    internal class FatalError : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FatalError" /> class.
        /// </summary>
        /// <param name="m">
        /// The error message.
        /// </param>
        public FatalError(string m) : base(m) { }
    }
}