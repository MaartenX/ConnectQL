/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
-->begin

-->namespace

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using ConnectQl.Internal.Ast;
using ConnectQl.Internal.Ast.Expressions;
using ConnectQl.Internal.Ast.Sources;
using ConnectQl.Internal.Ast.Statements;
using ConnectQl.Internal.Ast.Targets;
using ConnectQl.Internal.Interfaces;
using ConnectQl.Results;

/// <summary>
/// Event arguments for the <see cref="Parser.TokenScanned" /> event.
/// </summary>
internal class TokenScannedEventArgs : EventArgs
{
	/// <summary>
	/// Initializes a new instance of the <see cref="TokenScannedEventArgs" /> class.
	/// </summary>
	public TokenScannedEventArgs(Token token) 
	{
		this.Token = token;
	}
	
	/// <summary>
	/// Gets the token.
	/// </summary>
	public Token Token { get; }
}

/// <summary>
/// The parser.
/// </summary>
[GeneratedCode("CoCo/R", "0.1")]
internal partial class Parser {
-->constants

	/// <summary>
	/// The minimum distance between two errors.
	/// </summary>
	private const int MinimumErrDistance = 2;

	/// <summary>
	/// The node data provider.
	/// </summary>
	private readonly INodeDataProvider data;
	
	/// <summary>
	/// The scanner.
	/// </summary>
	private readonly Scanner scanner;
	
	/// <summary>
	/// The error writer.
	/// </summary>
	private readonly ErrorWriter errors;

	/// <summary>
	/// The last recognized token.
	/// </summary>
	private Token t;    

	/// <summary>
	/// The distance from the last error.
	/// </summary>
	private int errDist = MinimumErrDistance;

-->declarations
	
	/// <summary>
    /// Initializes a new instance of the <see cref="Parser"/> class.
    /// </summary>
    /// <param name="scanner">
    /// The scanner.
    /// </param>
	/// <param name="data">
	/// The data provider.
	/// </param>
	/// <param name="messages">
	/// The message writer.
	/// </param>
	public Parser(Scanner scanner, INodeDataProvider data, IMessageWriter messages) {
		this.scanner = scanner;
		this.data = data;
		this.errors = new ErrorWriter(messages);
	}
	 
	/// <summary>
	/// Raised when a token is scanned.
	/// </summary>
	public event EventHandler<TokenScannedEventArgs> TokenScanned;

	/// <summary>
	/// Gets the tokens.
	/// </summary>
	public IList<Token> Tokens { get; } = new List<Token>();

	/// <summary>
	/// Gets the statements that this parser generated.
	/// </summary>
	public List<StatementBase> Statements { get; private set; }

	/// <summary>
	/// Gets the look-ahead token.
	/// </summary>
	private Token LookAhead { get; set; }
 	
    /// <summary>
    /// Triggers a semantic error.
    /// </summary>
    /// <param name="lineFrom">
    /// The line number from.
    /// </param>
    /// <param name="lineTo">
    /// The line number to.
    /// </param>
    /// <param name="colTo">
    /// The column number to.
    /// </param>
    /// <param name="tokenIndexFrom">
    /// The token index from.
    /// </param>
    /// <param name="tokenIndexTo">
    /// The token index to.
    /// </param>
    /// <param name="colFrom">
    /// The column number from.
    /// </param>
    /// <param name="msg">
    /// The message.
    /// </param>
    public void SemErr(int lineFrom, int colFrom, int tokenIndexFrom, int lineTo, int colTo, int tokenIndexTo, string msg)
    {
        if (this.errDist >= MinimumErrDistance) 
		{
			this.errors.SemErr(lineFrom, colFrom, tokenIndexFrom, lineTo, colTo, tokenIndexTo, msg);
		}

        this.errDist = 0;
    }

	/// <summary>
    /// Triggers a semantic error.
    /// </summary>
    /// <param name="msg">
    /// The message.
    /// </param>
	public void SemErr (string msg) {
		if (this.errDist >= MinimumErrDistance) 
		{
			this.errors.SemErr(t.Line, t.Col, t.Index - 2, t.Line, t.Col + t.Val.Length, t.Index - 2, msg);
		}

		this.errDist = 0;
	}

	/// <summary>
	/// Triggers a syntactic error.
	/// </summary>
	/// <param name="n">
	/// The error number.
	/// </param>
	private void SynErr (int n) {
		if (this.errDist >= MinimumErrDistance) 
		{
			this.errors.SynErr(this.LookAhead.Line, this.LookAhead.Col, this.LookAhead.Index - 1, n);
		}

		this.errDist = 0;
	}
	
	/// <summary>
	/// Gets the next token.
	/// </summary>
	private void Get () {
		for (;;) {
			t = this.LookAhead;
			this.TokenScanned?.Invoke(this, new TokenScannedEventArgs(this.LookAhead));
			this.LookAhead = this.scanner.Scan();

			Tokens.Add(this.LookAhead);

			if (this.LookAhead.IsComment) {
				this.LookAhead = t;
				continue;
			}

			if (this.LookAhead.Kind <= MaxToken) { ++this.errDist; break; }
-->pragmas
			this.LookAhead = t;
		}
	} 
	
	/// <summary>
	/// Expects that the next token is the specified token.
	/// </summary>
	/// <param name="n">
	/// The token to expect.
	/// </param>
	private void Expect (int n) {
		if (this.LookAhead.Kind==n) 
		{ 
			Get(); 
		}
		else 
		{ 
			SynErr(n); 
		}
	}
	
	/// <summary>
	/// Checks if the next token is the start of the specifed set.
	/// </summary>
	/// <param name="s">
	/// The set number.
	/// </param>
	/// <returns>
	/// <c>true</c> if the token is the start of the set.
	/// </returns>
	private bool StartOf (int s) {
		return Set[s, this.LookAhead.Kind];
	}
	
	/// <summary>
	/// Expects that the next token is the specified token but keeps scanning if it wasn't found.
	/// </summary>
	/// <param name="n">
	/// The token to expect.
	/// </param>
	/// <param name="follow">
	/// The token that follows.
	/// </param>
	private void ExpectWeak (int n, int follow) {
		if (this.LookAhead.Kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}

	/// <summary>
	/// Tries to get the next token even if the separator is missing.
	/// </summary>
	/// <param name="n">
	/// The token number that specified the separator.
	/// </param>
	/// <param name="syFol">
	/// The symbol after the separator.
	/// </param>
	/// <param name="repFol">
	/// The symbol that ends the separated symbols.
	/// </param>
	/// <returns>
	/// <c>true</c> if the separator and symbol were found, false otherwise.
	/// </returns>
	private bool WeakSeparator(int n, int syFol, int repFol) {
		int kind = this.LookAhead.Kind;
		if (kind == n) {Get(); return true;}
		else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(Set[syFol, kind] || Set[repFol, kind] || Set[0, kind])) {
				Get(); 
				kind = this.LookAhead.Kind;
			}
			return StartOf(syFol);
		}
	}

	
-->productions

    /// <summary>
    /// Parses the text.
    /// </summary>
	public void Parse() {
		this.LookAhead = new Token();
		this.LookAhead.Val = "";		
		Get();
-->parseRoot
	}
	
	/// <summary>
	/// The initialization set.
	/// </summary>
	private static readonly bool[,] Set = {
-->initialization
	};
} 

/// <summary>
/// The error writer.
/// </summary>
[GeneratedCode("CoCo/R", "0.1")]
internal class ErrorWriter 
{
	/// <summary>
	/// The message writer to write to.
	/// </summary>
	private readonly IMessageWriter result;

	/// <summary>
	/// Initializes a new instance of the <see cref="ErrorWriter" /> class.
	/// </summary>
	/// <param name="result">
	/// The message writer to write to.
	/// </param>
	public ErrorWriter(IMessageWriter result) {
		this.result = result;
	}

	/// <summary>
	/// Writes a syntax error to the message writer.
	/// </summary>
	/// <param name="line">
	/// The line number where the error occured.
	/// </param>
	/// <param name="col">
	/// The column number where the error occured.
	/// </param>
	/// <param name="index">
	/// The index of the token.
	/// </param>
	/// <param name="n">
	/// The error number.
	/// </param>
	public virtual void SynErr (int line, int col, int index, int n) {
		string s;
		switch (n) {
-->errors
			default: s = "error " + n; break;
		}

		this.result.AddError(new Position { Line = line, Column = col, TokenIndex = index }, new Position { Line = line, Column = col, TokenIndex = index }, s);
	}
	
	/// <summary>
	/// Writes a semantic error to the message writer.
	/// </summary>
	/// <param name="lineFrom">
	/// The line number where the error started.
	/// </param>
	/// <param name="colFrom">
	/// The column number where the error started.
	/// </param>
	/// <param name="tokenIndexFrom">
	/// The token index where the error started.
	/// </param>
	/// <param name="lineTo">
	/// The line number where the error ended.
	/// </param>
	/// <param name="colTo">
	/// The column number where the error ended.
	/// </param>
	/// <param name="tokenIndexTo">
	/// The token index where the error ended.
	/// </param>
	/// <param name="s">
	/// The error message.
	/// </param>
	public virtual void SemErr (int lineFrom, int colFrom, int tokenIndexFrom, int lineTo, int colTo, int tokenIndexTo, string s) {
		this.result.AddError(new Position { Line = lineFrom, Column = colFrom, TokenIndex = tokenIndexFrom }, new Position { Line = lineFrom, Column = colFrom, TokenIndex = tokenIndexTo }, s);
	}
	
	/// <summary>
	/// Writes a semantic error to the message writer without a position.
	/// </summary>
	/// <param name="s">
	/// The error message.
	/// </param>
	public virtual void SemErr (string s) {
		this.result.AddError(new Position(), new Position(), s);
	}
	
	/// <summary>
	/// Writes a warning to the message writer.
	/// </summary>
	/// <param name="lineFrom">
	/// The line number where the error started.
	/// </param>
	/// <param name="colFrom">
	/// The column number where the error started.
	/// </param>
	/// <param name="lineTo">
	/// The line number where the error ended.
	/// </param>
	/// <param name="colTo">
	/// The column number where the error ended.
	/// </param>
	/// <param name="s">
	/// The warning message.
	/// </param>
	public virtual void Warning (int lineFrom, int colFrom, int lineTo, int colTo, string s) {
		this.result.AddWarning(new Position { Line = lineFrom, Column = colFrom }, new Position { Line = lineFrom, Column = colFrom }, s);
	}
	
	/// <summary>
	/// Writes a warning to the message writer without a position.
	/// </summary>
	/// <param name="s">
	/// The warning message.
	/// </param>
	public virtual void Warning(string s) {
		this.result.AddWarning(new Position(), new Position(), s);
	}
} 

/// <summary>
/// Thrown when a fatal error occurs.
/// </summary>
[GeneratedCode("CoCo/R", "0.1")]
internal class FatalError: Exception 
{
	/// <summary>
	/// Initializes a new instance of the <see cref="FatalError" /> class.
	/// </summary>
	/// <param name="m">
	/// The error message.
	/// </param>
	public FatalError(string m): base(m) {}
}
